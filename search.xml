<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构 —— 简单算术表达式计算]]></title>
    <url>%2F2019%2F04%2F26%2F%E7%AE%80%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目描述： 表达式求值是进行数据处理的最基本操作。请编写程序完成一个简单算术表达式的求值。要求如下： （1） 运算符包括：+、-、*、/、^(乘方)、括号 （2）运算量为数值常量，例如1位整数、多位整数、实数等； 输入：一行，即表达式，以“=”结束。例如： 5*(8-3)+6/5= 输出：一行，即表达式的值。结果值为整数时输出为整数，如果有小数时保留5位小数。 26.20000 解题思路： 该题考虑对栈的应用，可以使用两个栈：一个用于存放运算符，一个用于存放操作数。 具体做法： 遍历表达式，遇到运算符就考虑将其压入运算符栈中（预置一个#号，并设定其优先级最低），在压入之前比较栈中已存在的运算符，若比栈中已有运算符优先级大就压入栈中，否则将栈中运算符弹出，并从操作数栈弹出两个操作数进行运算并将结果压入操作数栈中，之后再与栈中剩余的运算符比较优先级，重复上述操作。 详细代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include "bits/stdc++.h"using namespace std;int get_level(char ch) &#123; // 获取运算符优先级 switch (ch) &#123; case '#': return 0; case '+': case '-': return 1; case '*': case '/': return 2; case '^': return 3; case '(': case ')': return 4; &#125;; return -1;&#125;double operate(char ch, double a, double b) &#123; //进行算术运算 switch (ch) &#123; case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': return a / b; case '^': return pow(a, b); &#125;; return 0;&#125;double strtodouble(string num) &#123; // 将字符串转double类型 亦可用c++11 内置的 stod() 函数代替 double number = 0; int flag = 0; double pos = 0; for (long long int i = num.length() - 1; i &gt;= 0; i--) &#123; if (flag == 0 &amp;&amp; num[i] != '.') &#123; number += (int(num[i]) - 48) * pow(10, num.length() - 1 - i); &#125; else if (flag &amp;&amp; num[i] != '.') &#123; number += (int(num[i]) - 48) * pow(10, num.length() - 1 - i - 1); &#125; if (num[i] == '.') &#123; flag = 1; pos = pow(10, num.length() - 1 - i); &#125; &#125; if (flag) number /= pos; return number;&#125;void output(double a) &#123; // 输出格式 long long b = a; if (a - b == 0) cout &lt;&lt; a &lt;&lt; endl; else printf("%.5f\n", a);&#125;int cal(stack&lt;double&gt; &amp;stack1, stack&lt;char&gt; &amp;stack2, char c) &#123; //传入栈引用 保证能被修改 // 表达式求值 if (get_level(stack2.top()) &lt; get_level(c)) &#123; //比栈顶部运算符优先级高 入栈（不为右括号） 要保证能将括号内算式运算进行完毕 括号不参与运算 仅改变优先级 if (c != ')') stack2.push(c); else &#123; char ch = stack2.top(); stack2.pop(); double num1 = stack1.top(); stack1.pop(); double num2 = stack1.top(); stack1.pop(); stack1.push(operate(ch, num2, num1)); cal(stack1, stack2, c); &#125; &#125; else if (get_level(stack2.top()) == get_level(c) &amp;&amp; (stack2.top() == '#' || (stack2.top() == '(') &amp;&amp; c == ')')) stack2.pop(); // 符号匹配 弹出 else &#123; if (!stack2.empty() &amp;&amp; (stack2.top() != '(')) &#123; // 优先级低于栈顶运算符 且栈顶运算符不为左括号 括号不参与具体运算 仅改变优先级 char ch = stack2.top(); stack2.pop(); double num1 = stack1.top(); stack1.pop(); double num2 = stack1.top(); stack1.pop(); stack1.push(operate(ch, num2, num1)); cal(stack1, stack2, c); &#125; else if (!stack2.empty() &amp;&amp; stack2.top() == '(') stack2.push(c); else return 0; &#125; return 0;&#125;int main() &#123; string st; string num; stack&lt;double&gt; stack1; //操作数栈 stack&lt;char&gt; stack2; // 运算符栈 cin &gt;&gt; st; double sum = 0; stack2.push('#'); // 预置# for (int i = 0; i &lt; st.length(); ++i) &#123; // 遍历表达式 if (st[i] == '+' || st[i] == '-' || st[i] == '*' || st[i] == '/' || st[i] == '^' || st[i] == '(' || st[i] == ')' || st[i] == '=') &#123; if (!num.empty()) &#123; stack1.push(strtodouble(num)); num.clear(); &#125; if (st[i] != '=') cal(stack1, stack2, st[i]); else if (st[i] == '=') cal(stack1, stack2, '#'); // 表达式结束时 向运算符栈压入# &#125; else num += st[i]; &#125; sum = stack1.top(); output(sum); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
